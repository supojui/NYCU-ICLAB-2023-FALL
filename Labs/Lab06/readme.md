## 簡介
這次要實作Huffman coding，詳細的演算法可以參考pdf，簡單講就是將一串數列排序後，將最小的兩個數組成子樹，並將兩數相加後組成的node重新與數列做排列，重複此步驟，直到全部的node形成一個樹，再根據是左還是右子樹去給上對應的coding，最後按照mode輸出對應的coding。

## 優化Tips
相比lab04、lab05，這個lab的複雜度明顯降低，但個人認為還是有點難度，要怎麼把很軟體的演算法轉成硬體應該是這次的重點，我們的方法performance沒有很好，基本上就是用in_weight_seq紀錄weight，如果組成子樹了，就把index大的那個位置空下來，並把值加起來存到前面的那個index裡；node_seq是用來記錄每個字母現在對應到的coding是甚麼，如果組成子樹了，就會根據是在子樹的左右去做append 0或1；height_seq是用來紀錄每個字母現在的coding長度應該是多少，因為我們的演算法是從前面加0或1，所以在取答案的時候要從MSB往後取，因此要有變數紀錄長度。

每次輸出答案需要7個cycle，且因為用了很多register，面積也沒有討到便宜，多找點人討論演算法，應該是會比這份code好很多。另外，這次lab還有提到soft ip，那個就只是把sorting的部分拉出來，額外包成一個module而已。
